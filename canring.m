/*
AUTHOR: JV

The below code, I believe, is very close to what we desire. It produces generators and stores 
them appropriately. It also stores relations and stores them. At the end it produces a graded
ring and ideal generated by the polynomials of the relations. 

TODO: 
- Try to make it run faster. Have it stop checking for generators after weight six is one way to do this
- Comment; I deleted most of my comments when we reformatted into this function based format, so should recomment
*/


// Helping Functions 

// For a given level, this function returns the smallest weight for 
// which the space of modular forms in that level and weight
// is not dimension 0
// Input : N = level
// Input : MaxWeight = the weight at which to stop checking
// Output := k = the lowest weight at which ModularForms(N,k) has positive dimension
SmallestWeight := function(N, maxWeight) 
	k := 2;
	while k le maxWeight div 2 do
		d := Dimension(ModularForms(N,k));
		if d eq 0 then
			k +:= 2;
		else
			return k; 
		end if;
	end while;
	error_str := "ModularForms(N,l) had dimension 0 for all l up to MaxWeight";
	return error_str;
end function;

// This function returns the minimum precision to be used, with a buffer
// Input := N = level
// Input := k = weight
// Optional Input := Buffer = additional precision to be used
// Output := minimum precision, accounting for buffer
MinimumPrecision := function(N,k : Buffer := 12)
  	heckeBound := Ceiling(k/12)*Index(Gamma0(N));
	return heckeBound + Buffer;
end function;

// Given a matrix of row vectors, finds linear relations amongst the rows
// Input := matrix = any matrix
// Output := a list of all relations amongst rows of matrix
FindRelations := function(matrix) 
	kernelOfMatrix := Kernel(matrix);
	relations := [Eltseq(v) : v in Basis(kernelOfMatrix)];
	return relations;
end function;


// New generators are found in vector form. This turns them into modular forms. It could be done using something 
// similar to VectorsInTermsOfBasis below, but I need to make them have the same inputs
// Input: NewGenVectors = a list of vectors representing new generators
// Input: N = level
// Input: k = weight
// Input: CurrentWeightBasis = a basis of ModularForms(N,k); could be computed here but is expensive, so passed in
// Output: a list of modular forms, one corresponding to each element of NewGenVectors
NewGeneratorsVectorsToForms := function(NewGenVectors, N, k,CurrentWeightBasis)
	genMFs := [];
	prec := MinimumPrecision(N,k);
	CurWeightVectBasis:=[AbsEltseq(qExpansion(CurrentWeightBasis[i],prec)):i in [1..#CurrentWeightBasis]];
	//modzero := BaseExtend(ModularForms(N, k),Rationals())!0;
	for l := 1 to #NewGenVectors do
		matrix := Matrix(Append(CurWeightVectBasis,Eltseq(NewGenVectors[l])[1..prec]));
		relation := Basis(Kernel(matrix))[1];
		//CurrentGenerator := modzero;
		CurrentGenerator := relation[1]*CurrentWeightBasis[1]/(-1*relation[#Eltseq(relation)]);
		for j := 1 to #CurrentWeightBasis do
			CurrentGenerator := CurrentGenerator + relation[j]*CurrentWeightBasis[j]/(-1*relation[#Eltseq(relation)]);
		end for;
		Append(~genMFs,CurrentGenerator);
	end for;
  return genMFs;
end function;

// Given a list of generators and their weights, finds all weighted monomials of weight k
// Input: GenList = a list of generators
// Input: GenWeights = the weights of the generators
// Input: k = the weight you want monomials in
// Output: both the evaluated monomials, so a list of modular forms, and the formal monomials
ProduceMonomials := function(GenList,GenWeights, k)
	R<[x]> := PolynomialRing(Rationals(),GenWeights);
	FormalMonomials := MonomialsOfWeightedDegree(R,k);

	// Now evaluate these monomials at the generators
	EvalMonomials := [];
	for j := 1 to #FormalMonomials do 
		Exp := Exponents(FormalMonomials[j]);
		CurrMonomial := 1;
		for k := 1 to #GenList do 
			if Exp[k] ne 0 then
				CurrMonomial := CurrMonomial * GenList[k]^Exp[k];
			end if;
		end for;
		EvalMonomials[j] := CurrMonomial;
	end for;
	return EvalMonomials,FormalMonomials;
end function;


// Given monomials and a number of relations amongst them, computes the rest of a basis
// of ModularForms(N,k)
// Input: N = level
// Input: k = weight
// Input: EvaluatedMonomials = list of ModularForms, generated by weighted monomials of generators
// Input: NumberOfRelations = the total number of relations amongst those monomials
// Output: a list of modular forms, one corresponding to each new generator
FindNewGenerators := function(N,k,EvaluatedMonomials,NumberOfRelations)
	prec := MinimumPrecision(N,k);

	V := VectorSpace(Rationals(),prec);

	// Space of modular forms of CurrentWeight
	ModularFormsCurrentWeight := BaseExtend(ModularForms(N,k),Rationals());
	CurrentWeightBasis := Basis(ModularFormsCurrentWeight);
	CurrentWeightVectorBasis := [AbsEltseq(qExpansion(CurrentWeightBasis[i],prec)):i in [1..#CurrentWeightBasis]];

	VectorEvaluatedMonomials := [AbsEltseq(qExpansion(EvaluatedMonomials[i],prec)):i in [1..#EvaluatedMonomials]];
	MonomialSubspace := sub<V|VectorEvaluatedMonomials>;
	// The below is the same as Dimension(MonomialSubspace) but cheaper computationally
	numLinIndMonomials := #EvaluatedMonomials - NumberOfRelations;

	CurrentWeightSubspace := sub<V|CurrentWeightVectorBasis>;
	ExtendedMonomialBasis := ExtendBasis(MonomialSubspace,CurrentWeightSubspace);
	NewGeneratorsVec := [ExtendedMonomialBasis[i]:i in [numLinIndMonomials+1..#ExtendedMonomialBasis]];	

	NewGens := NewGeneratorsVectorsToForms(NewGeneratorsVec,N,k,CurrentWeightBasis);
	return NewGens;
end function;

// This is somewhat of a coerce operator. Given an input vector of coefficients, it returns
// both the modular form in the specified space representing that, and an expression of 
// that modular form in terms of monomials of generators
// Input: N=level, k=weight
// Input: genList = a list of generators
// Input: genWeights = their weights
// Input: inputVector = the vector to be turned into a modular form
// Output: modular form in specified space that agrees with inputVector coefficients, expression of that form
//		in terms of monomials of generators
VectorInTermsOfBasis := function(N,k,genList,genWeights,inputVector) 
	prec := MinimumPrecision(N,k);
	assert #inputVector ge prec;

	evaluatedMonomials,formalMonomials := ProduceMonomials(genList,genWeights,k);
	
	
	qExpansionVector := [AbsEltseq(qExpansion(evaluatedMonomials[i],prec)):i in [1..#evaluatedMonomials]];
	Append(~qExpansionVector,inputVector[1..prec]);

	matCombos := Matrix(qExpansionVector);
	relationList := FindRelations(matCombos);
	relation := [];

	// Find the relation that doesnâ€™t have a zero in last slot
	for i in relationList do
		if i[#i] ne 0 then
			relation := i;
		end if;
	end for;

	outputMonomial := 0;
	outputForm := BaseExtend(ModularForms(N,k),Rationals())!0;
	for j := 1 to #evaluatedMonomials do
		outputForm := outputForm + relation[j]*evaluatedMonomials[j]/(-1*relation[#relation]);
		outputMonomial := outputMonomial + relation[j]*formalMonomials[j]/(-1*relation[#relation]);
	end for;

	return outputForm,outputMonomial;
end function;

// One of two main control functions
// Input: N=level
// Input: MaxWeight = highest weight to check for relations in
// Output: Associative array of generators in each weight, those generators in a list, 
//		the weights of the generators, a list of relations and list of what weight those relations are in
ConstructGeneratorsAndRelations := function(N, MaxWeight)
	Gens := AssociativeArray();
	GenWeights := [];
	GenList := [* *];
	Rels := [];
	RelWeights := [];

  	LowestWeight := SmallestWeight(N, MaxWeight);
	FirstGenerators := Basis(BaseExtend(ModularForms(N, LowestWeight),Rationals()));
	Gens[LowestWeight] := FirstGenerators;
	GenWeights := GenWeights cat [LowestWeight : i in [1..#FirstGenerators]];

	for i := (LowestWeight div 2 + 1) to (MaxWeight div 2) do
		k := 2*i;
		Gens[k] := [];
		GenList := GenList cat [* f : f in Gens[k - 2]*];

		EvaluatedMonomials := ProduceMonomials(GenList, GenWeights, k);
		#EvaluatedMonomials;

		NumNewRelations := 0;
		if #EvaluatedMonomials ne 0 then
			prec := MinimumPrecision(N,k);
			matCombos := Matrix([AbsEltseq(qExpansion(EvaluatedMonomials[i],prec)):i in [1..#EvaluatedMonomials]]);
			NewRelations := FindRelations(matCombos);
			Rels := Rels cat NewRelations;
			RelWeights := RelWeights cat [k : i in [1..#NewRelations]];
			NumNewRelations := #NewRelations;
		end if;

		if k le (MaxWeight div 2) then 
			NewGensModForms := FindNewGenerators(N, k, EvaluatedMonomials, NumNewRelations);
			Gens[k] := NewGensModForms;
			GenWeights := GenWeights cat [k : i in [1..#NewGensModForms]];

		end if;
	end for;

	return Gens,GenList,GenWeights,Rels,RelWeights;
end function;

// Input: Rels = relations amongst monomials
// Input: RelWeights = what weight those relations are in
// Input: GradedRing = a graded ring that includes the weights of the relations
// Output: polynomials in the graded ring representing the relations
MakePolyList := function(Rels,RelWeights,GradedRing) 
	PolynomialList := [];
	for i := 1 to #Rels do
		CurrentRelationWeight := RelWeights[i];
		CurrentRelation := Rels[i];
		Monomials := MonomialsOfWeightedDegree(GradedRing,CurrentRelationWeight);
		CurrentRelationPolynomial := 0;
		for j := 1 to #CurrentRelation do 
			CurrentRelationPolynomial := CurrentRelationPolynomial + Monomials[j]*CurrentRelation[j];
		end for;
		Append(~PolynomialList,CurrentRelationPolynomial);
	end for;
	return PolynomialList;
end function;

// The other main control function. Turns the work of ConstructGeneratorsAndRelations into our 
// quotient ring
// Input: most of the output of ConstructGeneratorsAndRelations, N=level
// Output: R = polynomial ring with weighted generators
// Output: I = ideal generated by relations in R
// Output: R/I
ConstructRingAndIdeal := function(GenWeights,Rels,RelWeights,N) 
	R := PolynomialRing(Rationals(),GenWeights);
	PolynomialList := MakePolyList(Rels,RelWeights,R);

	I := ideal<R | PolynomialList>;
	MGamma := quo<R | I>;

	
	// Sanity check that the Hilbert series matches
	//_<t> := PowerSeriesRing(Rationals());
	//HSeries := Parent(t)!HilbertSeries(MGamma);    
	//len := AbsolutePrecision(HSeries);
	//UpdatedHSeries := 1 + &+[Dimension(ModularForms(N, 2*d))*t^(2*d) : d in [1..(len) div 2]] + BigO(t^(len));
	//assert HSeries eq UpdatedHSeries;
	

	return R, I, MGamma;
end function;


// Constructs the canonical ring of the modular curve X_0(N)
// as the graded ring of modular forms
// Input: N = level
// Optional input: MaxWeight = maximum weight for relations, twice weight for generators
CanonicalRing := function(N : MaxWeight := 12)
	gens,genList,genWeights,rels,relWeights := ConstructGeneratorsAndRelations(N,MaxWeight);
	R,I,MGamma := ConstructRingAndIdeal(genWeights,rels,relWeights,N);

	return R,I,MGamma, quo<R | I>,genList,genWeights;
end function;

/*
// Example call
CanonicalRing(23);
*/